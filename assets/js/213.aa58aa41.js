(window.webpackJsonp=window.webpackJsonp||[]).push([[213],{2402:function(s,n,e){"use strict";e.r(n);var a=e(4),t=Object(a.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[s._v("#")]),s._v(" 前言")]),s._v(" "),a("p",[s._v("npm 是 Node.JS 的包管理工具，除此之外，社区有一些类似的包管理工具如 yarn、pnpm 和 cnpm，以及集团内部使用的 tnpm。我们在项目开发过程中通常使用以上主流包管理器生成 node_modules 目录安装依赖并进行依赖管理。本文主要探究前端包管理器的依赖管理原理，希望对读者有所帮助。")]),s._v(" "),a("h2",{attrs:{id:"npm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#npm"}},[s._v("#")]),s._v(" npm")]),s._v(" "),a("p",[s._v("当我们执行 "),a("code",[s._v("npm install")]),s._v(" 命令后，npm 会帮我们下载对应依赖包并解压到本地缓存，然后构造 node_modules 目录结构，写入依赖文件。那么，对应的包在 node_modules 目录内部是怎样的结构呢，npm 主要经历了以下几次变化。")]),s._v(" "),a("h3",{attrs:{id:"_1、npm-v1-v2-依赖嵌套"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、npm-v1-v2-依赖嵌套"}},[s._v("#")]),s._v(" 1、npm v1/v2 依赖嵌套")]),s._v(" "),a("p",[s._v("npm 最早的版本中使用了很简单的嵌套模式进行依赖管理。比如我们在项目中依赖了 A 模块和 C 模块，而 A 模块和 C 模块依赖了不同版本的 B 模块，此时生成的 node_modules 目录如下：\n"),a("img",{attrs:{src:e(745),alt:""}}),s._v(" "),a("img",{attrs:{src:e(756),alt:""}})]),s._v(" "),a("h4",{attrs:{id:"依赖地狱-dependency-hell"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖地狱-dependency-hell"}},[s._v("#")]),s._v(" 依赖地狱（Dependency Hell）")]),s._v(" "),a("p",[s._v("可以看到这种是嵌套的 node_modules 结构，每个模块的依赖下面还会存在一个 node_modules 目录来存放模块依赖的依赖。这种方式虽然简单明了，但存在一些比较大的问题。如果我们在项目中增加一个同样依赖 2.0 版本 B 的模块 D，此时生成的 node_modules 目录便会如下所示。虽然模块 A、D 依赖同一个版本 B，但 B 却重复下载安装了两遍，造成了重复的空间浪费。这便是依赖地狱问题。")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("node_modules\n├── A@1.0.0\n│ └── node_modules\n│ └── B@1.0.0\n├── C@1.0.0\n│ └── node_modules\n│ └── B@2.0.0\n└── D@1.0.0\n└── node_modules\n└── B@1.0.0\n")])])]),a("p",[s._v("一些著名的梗图：\n"),a("img",{attrs:{src:e(764),alt:""}}),s._v(" "),a("img",{attrs:{src:e(765),alt:""}})]),s._v(" "),a("h3",{attrs:{id:"_2、npm-v3-扁平化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、npm-v3-扁平化"}},[s._v("#")]),s._v(" 2、npm v3 扁平化")]),s._v(" "),a("p",[s._v("npm v3 完成重写了依赖安装程序，npm3 通过扁平化的方式将子依赖项安装在主依赖项所在的目录中（hoisting 提升），以减少依赖嵌套导致的深层树和冗余。此时生成的 node_modules 目录如下：\n"),a("img",{attrs:{src:e(766),alt:""}}),s._v(" "),a("img",{attrs:{src:e(767),alt:""}}),s._v("\n为了确保模块的正确加载，npm 也实现了额外的依赖查找算法，核心是递归向上查找 node_modules。在安装新的包时，会不停往上级 node_modules 中查找。如果找到相同版本的包就不会重新安装，在遇到版本冲突时才会在模块下的 node_modules 目录下存放该模块子依赖，解决了大量包重复安装的问题，依赖的层级也不会太深。")]),s._v(" "),a("p",[s._v("扁平化的模式解决了依赖地狱的问题，但也带来了额外的新问题。")]),s._v(" "),a("h4",{attrs:{id:"幽灵依赖-phantom-dependency"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#幽灵依赖-phantom-dependency"}},[s._v("#")]),s._v(" 幽灵依赖（Phantom dependency）")]),s._v(" "),a("p",[s._v("幽灵依赖主要发生某个包未在 package.json 中定义，但项目中依然可以引用到的情况下。考虑之前的案例，它的 package.json 如右图所示。")]),s._v(" "),a("p",[a("img",{attrs:{src:e(768),alt:""}}),s._v(" "),a("img",{attrs:{src:e(769),alt:""}})]),s._v(" "),a("p",[s._v("在 index.js 中我们可以直接 require A，因为在 package.json 声明了该依赖，但是，我们 require B 也是可以正常工作的。")]),s._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("A")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'A'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("B")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'B'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// ???")]),s._v("\n")])])]),a("p",[s._v("因为 B 是 A 的依赖项，在安装过程中，npm 会将依赖 B 平铺到 node_modules 下，因此 require 函数可以查找到它。但这可能会导致意想不到的问题：")]),s._v(" "),a("ul",[a("li",[s._v("依赖不兼容：my-library 库中并没有声明依赖 B 的版本，因此 B 的 major 更新对于 SemVer 体系是完全合法的，这就导致其他用户安装时可能会下载到与当前依赖不兼容的版本。")]),s._v(" "),a("li",[s._v("依赖缺失：我们也可以直接引用项目中 devDepdency 的子依赖，但其他用户安装时并不会 devDepdency，这就可能导致运行时会立刻报错。")])]),s._v(" "),a("h4",{attrs:{id:"多重依赖-doppelgangers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多重依赖-doppelgangers"}},[s._v("#")]),s._v(" 多重依赖（doppelgangers）")]),s._v(" "),a("p",[a("img",{attrs:{src:e(770),alt:""}}),s._v("\n考虑在项目中继续引入的依赖 2.0 版本 B 的模块 D 与而 1.0 版本 B 的模块 E，此时无论是把 B 2.0 还是 1.0 提升放在顶层，都会导致另一个版本存在重复的问题，比如这里重复的 2.0。此时就会存在以下问题：")]),s._v(" "),a("ul",[a("li",[s._v("破坏单例模式：模块 C、D 中引入了模块 B 中导出的一个单例对象，即使代码里看起来加载的是同一模块的同一版本，但实际解析加载的是不同的 module，引入的也是不同的对象。如果同时对该对象进行副作用操作，就会产生问题。")]),s._v(" "),a("li",[s._v("types 冲突：虽然各个 package 的代码不会相互污染，但是他们的 types 仍然可以相互影响，因此版本重复可能会导致全局的 types 命名冲突。")])]),s._v(" "),a("h4",{attrs:{id:"不确定性-non-determinism"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不确定性-non-determinism"}},[s._v("#")]),s._v(" 不确定性（Non-Determinism）")]),s._v(" "),a("p",[s._v("在前端包管理的背景下，确定性指在给定 package.json 下，无论在何种环境下执行 npm install 命令都能得到相同的 node_modules 目录结构。然而 npm v3 是不确定性的，它 node_modules 目录以及依赖树结构取决于用户安装的顺序。")]),s._v(" "),a("p",[s._v("考虑项目拥有以下依赖树结构，其 npm install 产生的 node_modules 目录结构如右图所示。\n"),a("img",{attrs:{src:e(746),alt:""}}),s._v(" "),a("img",{attrs:{src:e(747),alt:""}}),s._v("\n假设当用户使用 npm 手动升级了模块 A 到 2.0 版本，导致其依赖的模块 B 升级到了 2.0 版本，此时的依赖树结构如下。\n"),a("img",{attrs:{src:e(748),alt:""}}),s._v(" "),a("img",{attrs:{src:e(749),alt:""}}),s._v("\n此时完成开发，将项目部署至服务器，重新执行 npm install，此时提升的子依赖 B 版本发生了变化，产生的 node_modules 目录结构将会与用户本地开发产生的结构不同，如下图所示。如果需要 node_modules 目录结构一致，就需要在 package.json 修改时删除 node_modules 结构并重新执行 npm install。\n"),a("img",{attrs:{src:e(750),alt:""}}),s._v(" "),a("img",{attrs:{src:e(751),alt:""}})]),s._v(" "),a("h3",{attrs:{id:"_3、npm-v5-扁平化-lock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、npm-v5-扁平化-lock"}},[s._v("#")]),s._v(" 3、npm v5 扁平化+lock")]),s._v(" "),a("p",[s._v("在 npm v5 中新增了 package-lock.json。当项目有 package.json 文件并首次执行 npm install 安装后，会自动生成一个 package-lock.json 文件，该文件里面记录了 package.json 依赖的模块，以及模块的子依赖。并且给每个依赖标明了版本、获取地址和验证模块完整性哈希值。通过 package-lock.json，保障了依赖包安装的确定性与兼容性，使得每次安装都会出现相同的结果。")]),s._v(" "),a("h4",{attrs:{id:"一致性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一致性"}},[s._v("#")]),s._v(" 一致性")]),s._v(" "),a("p",[s._v("考虑上文案例，初始时安装生成 package-lock.json 如左图所示，depedencies 对象中列出的依赖都是提升的，每个依赖项中的 requires 对象中为子依赖项。此时更新 A 依赖到 2.0 版本，如右图所示，并不会改变提升的子依赖版本。因此重新生成的 node_modules 目录结构将不会发生变化。\n"),a("img",{attrs:{src:e(752),alt:""}}),s._v(" "),a("img",{attrs:{src:e(753),alt:""}})]),s._v(" "),a("h4",{attrs:{id:"兼容性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#兼容性"}},[s._v("#")]),s._v(" 兼容性")]),s._v(" "),a("h5",{attrs:{id:"语义化版本-semantic-versioning"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语义化版本-semantic-versioning"}},[s._v("#")]),s._v(" 语义化版本（Semantic Versioning）")]),s._v(" "),a("p",[s._v("依赖版本兼容性就不得不提到 npm 使用的 SemVer 版本规范，版本格式如下：")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("主版本号：不兼容的 API 修改")])]),s._v(" "),a("li",[a("p",[s._v("次版本号：向下兼容的功能性新增")])]),s._v(" "),a("li",[a("p",[s._v("修订号：向下兼容的问题修正\n"),a("img",{attrs:{src:e(754),alt:""}}),s._v("\n在使用第三方依赖时，我们通常会在 package.json 中指定依赖的版本范围，语义化版本范围规定：")])]),s._v(" "),a("li",[a("p",[s._v("~：只升级修订号")])]),s._v(" "),a("li",[a("p",[s._v("^：升级次版本号和修订号")])]),s._v(" "),a("li",[a("p",[s._v("*：升级到最新版本")])])]),s._v(" "),a("p",[s._v("语义化版本规则定义了一种理想的版本号更新规则，希望所有的依赖更新都能遵循这个规则，但是往往会有许多依赖不是严格遵循这些规定的。因此一些依赖模块子依赖不经意的升级，可能就会导致不兼容的问题产生。因此 package-lock.json 给每个模块子依赖标明了确定的版本，避免不兼容问题的产生。")]),s._v(" "),a("h2",{attrs:{id:"yarn"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#yarn"}},[s._v("#")]),s._v(" Yarn")]),s._v(" "),a("p",[s._v("Yarn 是在 2016 年开源的，yarn 的出现是为了解决 npm v3 中的存在的一些问题，那时 npm v5 还没发布。Yarn 被定义为快速、安全、可靠的依赖管理。")]),s._v(" "),a("h3",{attrs:{id:"_1、yarn-v1-lockfile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、yarn-v1-lockfile"}},[s._v("#")]),s._v(" 1、Yarn v1 lockfile")]),s._v(" "),a("p",[s._v("Yarn 生成的 node_modules 目录结构和 npm v5 是相同的，同时默认生成一个 yarn.lock 文件。对于上文例子，生成的 yarn.lock 文件如下：")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v("A@^1.0.0:\n  version "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"1.0.0"')]),s._v("\n  resolved "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"uri"')]),s._v("\n dependencies:\n    B "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"^1.0.0"')]),s._v("\n\nB@^1.0.0:\n  version "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"1.0.0"')]),s._v("\n  resolved "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"uri"')]),s._v("\n\nB@^2.0.0:\n  version "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"2.0.0"')]),s._v("\n  resolved "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"uri"')]),s._v("\n\nC@^2.0.0:\n  version "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"2.0.0"')]),s._v("\n  resolved "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"uri"')]),s._v("\n dependencies:\n    B "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"^2.0.0"')]),s._v("\n\nD@^2.0.0:\n  version "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"2.0.0"')]),s._v("\n  resolved "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"uri"')]),s._v("\n  dependencies:\n    B "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"^2.0.0"')]),s._v("\n\nE@^1.0.0:\n  version "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"1.0.0"')]),s._v("\n  resolved "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"uri"')]),s._v("\n  dependencies:\n    B "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"^1.0.0"')]),s._v("\n")])])]),a("p",[s._v("可以看到 yarn.lock 使用自定义格式而不是 JSON，并将所有依赖都放在顶层，给出的理由是便于阅读和审查，减少合并冲突。")]),s._v(" "),a("p",[a("strong",[s._v("Yarn lock vs. npm lock")])]),s._v(" "),a("ul",[a("li",[s._v("文件格式不同，npm v5 使用的是 json 格式，yarn 使用的是自定义格式")]),s._v(" "),a("li",[s._v("package-lock.json 文件里记录的依赖的版本都是确定的，不会出现语义化版本范围符号(~ ^ *)，而 yarn.lock 文件里仍然会出现语义化版本范围符号")]),s._v(" "),a("li",[s._v("package-lock.json 文件内容更丰富，实现了更密集的锁文件，包括子依赖的提升信息\n"),a("ul",[a("li",[s._v("npm v5 只需要 package.lock 文件就可以确定 node_modules 目录结构")]),s._v(" "),a("li",[s._v("yarn.lock 无法确定顶层依赖，需要 package.json 和 yarn.lock 两个文件才能确定 node_modules 目录结构。node_modules 目录中 package 的位置是在 yarn 的内部计算出来的，在使用不同版本的 yarn 时可能会引起不确定性。")])])])]),s._v(" "),a("h3",{attrs:{id:"_2、yarn-v2-plug-n-play"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、yarn-v2-plug-n-play"}},[s._v("#")]),s._v(" 2、Yarn v2 Plug’n’Play")]),s._v(" "),a("p",[s._v("在 Yarn 的 2.x 版本重点推出了 Plug’n’Play（PnP）零安装模式，放弃了 node_modules，更加保证依赖的可靠性，构建速度也得到更大的提升。")]),s._v(" "),a("p",[s._v("因为 Node 依赖于 node_modules 查找依赖，node_modules 的生成会涉及到下载依赖包、解压到缓存、拷贝到本地文件目录等一系列重 IO 的操作，包括依赖查找以及处理重复依赖都是非常耗时操作，基于 node_modules 的包管理器并没有很多优化的空间。因此 yarn 反其道而行之，既然包管理器已经拥有了项目依赖树的结构，那也可以直接由包管理器通知解释器包在磁盘上的位置并管理依赖包版本与子依赖关系。")]),s._v(" "),a("p",[s._v("执行 "),a("code",[s._v("yarn --pnp")]),s._v(" 模式即可开启 PnP 模式。在 PnP 模式，yarn 会生成 .pnp.cjs 文件代替 node_modules。该文件维护了依赖包到磁盘位置与子依赖项列表的映射。同时 .pnp.js 还实现了 resolveRequest 方法处理 require 请求，该方法会直接根据映射表确定依赖在文件系统中的位置，从而避免了在 node_modules 查找依赖的 I/O 操作。")]),s._v(" "),a("p",[a("img",{attrs:{src:e(755),alt:""}}),s._v("\npnp 模式优缺点也非常明显：")]),s._v(" "),a("ul",[a("li",[s._v("优：摆脱 node_modules，安装、模块速度加载快；所有 npm 模块都会存放在全局的缓存目录下，避免多重依赖；严格模式下子依赖不会提升，也避免了幽灵依赖（但这可能会导致某些包出现问题，因此也支持了依赖提升的宽松模式:<）。")]),s._v(" "),a("li",[s._v("缺：自建 resolver 处理 Node require 方法，执行 Node 文件需要通过 yarn node 解释器执行，脱离 Node 现存生态，兼容性不太好")])]),s._v(" "),a("h2",{attrs:{id:"pnpm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pnpm"}},[s._v("#")]),s._v(" pnpm")]),s._v(" "),a("p",[s._v("pnpm1.0 于 2017 年正式发布，pnpm 具有安装速度快、节约磁盘空间、安全性好等优点，它的出现也是为了解决 npm 和 yarn 存在的问题。")]),s._v(" "),a("p",[s._v("因为在基于 npm 或 yarn 的扁平化 node_modules 的结构下，虽然解决了依赖地狱、一致性与兼容性的问题，但多重依赖和幽灵依赖并没有好的解决方式。因为在不考虑循环依赖的情况下，实际的依赖结构图为有向无环图(DAG)，但是 npm 和 yarn 通过文件目录和 node resolve 算法模拟的实际上是有向无环图的一个超集（多出了很多错误祖先节点和兄弟节点之间的链接），这导致了很多的问题。pnpm 也是通过硬链接与符号链接结合的方式，更加精确的模拟 DAG 来解决 yarn 和 npm 的问题。")]),s._v(" "),a("h3",{attrs:{id:"_1、非扁平化的-node-modules"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、非扁平化的-node-modules"}},[s._v("#")]),s._v(" 1、非扁平化的 node_modules")]),s._v(" "),a("h4",{attrs:{id:"硬链接-hard-link-节约磁盘空间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#硬链接-hard-link-节约磁盘空间"}},[s._v("#")]),s._v(" 硬链接(hard link)节约磁盘空间")]),s._v(" "),a("p",[s._v("硬链接可以理解为源文件的副本，使得用户可以通过不同的路径引用方式去找到某个文件，他和源文件一样的大小但是事实上却不占任何空间。pnpm 会在全局 store 目录里存储项目 node_modules 文件的硬链接。硬链接可以使得不同的项目可以从全局 store 寻找到同一个依赖，大大节省了磁盘空间。")]),s._v(" "),a("h4",{attrs:{id:"符号链接-symbolic-link-创建嵌套结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#符号链接-symbolic-link-创建嵌套结构"}},[s._v("#")]),s._v(" 符号链接(symbolic link)创建嵌套结构")]),s._v(" "),a("p",[s._v("软链接可以理解为快捷方式，pnpm 在引用依赖时通过符号链接去找到对应磁盘目录（.pnpm）下的依赖地址。考虑在项目中安装依赖于 foo 模块的 bar 模块，生成的 node_modules 目录如下所示。\n"),a("img",{staticClass:"md-image",attrs:{src:e(757),alt:""}}),s._v(" "),a("img",{attrs:{src:e(758),alt:""}}),s._v("\n可以看到 node_modules 下的 bar 目录下并没有 node_modules，这是一个符号链接，实际真正的文件位于.pnpm 目录中对应的 "),a("code",[s._v("<package-name>@version/node_modules/<package-name>")]),s._v(" 目录并硬链接到全局 store 中。而 bar 的依赖存在于.pnpm 目录下 "),a("code",[s._v("<package-name>@version/node_modules")]),s._v(" 目录下，而这也是软链接到 "),a("code",[s._v("<package-name>@version/node_modules/<package-name>")]),s._v(" 目录并硬链接到全局 store 中。")]),s._v(" "),a("p",[s._v("而这种嵌套 node_modules 结构的好处在于只有真正在依赖项中的包才能访问，避免了使用扁平化结构时所有被提升的包都可以访问，很好地解决了幽灵依赖的问题。此外，因为依赖始终都是存在 store 目录下的硬链接，相同的依赖始终只会被安装一次，多重依赖的问题也得到了解决。")]),s._v(" "),a("p",[s._v("官网上的这张图清晰地解释了 pnpm 的依赖管理机制\n"),a("img",{attrs:{src:e(759),alt:""}})]),s._v(" "),a("h3",{attrs:{id:"_2、局限性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、局限性"}},[s._v("#")]),s._v(" 2、局限性")]),s._v(" "),a("p",[s._v("看起来 pnpm 似乎很好地解决了问题，但也存在一些局限。")]),s._v(" "),a("ul",[a("li",[s._v("忽略了 package-lock.json。npm 的锁文件旨在反映平铺的 node_modules 布局，但是 pnpm 默认创建隔离布局，无法由 npm 的锁文件格式反映出来，而是使用自身的锁文件 pnpm-lock.yaml。")]),s._v(" "),a("li",[s._v("符号链接兼容性。存在符号链接不能适用的一些场景，比如 Electron 应用、部署在 lambda 上的应用无法使用 pnpm。")]),s._v(" "),a("li",[s._v("子依赖提升到同级的目录结构，虽然由于 Node.js 的父目录上溯寻址逻辑，可以实现兼容。但对于类似 Egg、Webpack 的插件加载逻辑，在用到相对路径的地方，需要去适配。")]),s._v(" "),a("li",[s._v("不同应用的依赖是硬链接到同一份文件，如果在调试时修改了文件，有可能会无意中影响到其他项目。")])]),s._v(" "),a("h2",{attrs:{id:"cnpm-和-tnpm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cnpm-和-tnpm"}},[s._v("#")]),s._v(" cnpm 和 tnpm")]),s._v(" "),a("p",[a("img",{attrs:{src:e(760),alt:""}}),s._v("\ncnpm 是由阿里维护并开源的 npm 国内镜像源，支持官方 npm registry 的镜像同步。tnpm 是在 cnpm 基础之上，专为阿里巴巴经济体的同学服务，提供了私有的 npm 仓库，并沉淀了很多 Node.js 工程实践方案。")]),s._v(" "),a("p",[s._v("cnpm/tnpm 的依赖管理是借鉴了 pnpm ，通过符号链接方式创建非扁平化的 node_modules 结构，最大限度提高了安装速度。安装的依赖包都是在 node_modules 文件夹以包名命名，然后再做符号链接到 版本号 @包名的目录下。与 pnpm 不同的是，cnpm 没有使用硬链接，也未把子依赖符号链接到单独目录进行隔离。\n"),a("img",{staticClass:"md-image",attrs:{src:e(761),alt:""}}),s._v(" "),a("img",{attrs:{src:e(762),alt:""}}),s._v("\n此外，tnpm 新推出的 rapid 模式使用用户态文件系统（FUSE）对依赖管理做了一些新的优化。FUST 类似于文件系统版的 ServiceWorker，通过 FUSE 可以接管一个目录的文件系统操作逻辑。基于此实现非扁平化的 node_modules 结构可以解决软链接的兼容性问题。限于篇幅原因这里不再详述，感兴趣可以移步真·深入浅出 tnpm rapid 模式 - 如何比 pnpm 快 10 秒。")]),s._v(" "),a("h2",{attrs:{id:"其他"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[s._v("#")]),s._v(" 其他")]),s._v(" "),a("h3",{attrs:{id:"deno"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#deno"}},[s._v("#")]),s._v(" Deno")]),s._v(" "),a("p",[s._v("通过上文探究的主流包管理器依赖管理机制，我们发现无论扁平化或非扁平化 node_modules 结构似乎都不完美，抛弃 node_modules 的 PnP 模式又不兼容当前 Node 的生态，无解。看起来似乎是 Node 与 node_modules 自身有点问题(?)。Node.JS 作者 Ryan 也在 JSConf 上承认 node_modules 是他对 Node 的十大遗憾之一，但已经无法挽回了，随后他推荐了自己的新作 Deno。那让我们看看 JS 的另一大运行时环境 Deno 是如何进行依赖管理的。")]),s._v(" "),a("p",[a("img",{attrs:{src:e(763),alt:""}}),s._v("\n在 Deno 不使用 npm、package.json 以及 node_modules，而是将引入源、包名、版本号、模块名全部塞进了 URL 里，通过 URL 导入依赖并进行全局统一缓存，不仅节省了磁盘空间，也优化了项目结构。")]),s._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("as")]),s._v(" log "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'https://deno.land/std@0.125.0/log/mod.ts'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[s._v("因此 Deno 中没有包管理器的概念，对于项目中的依赖管理，Deno 提供了这样一种方案。由开发者创建 "),a("code",[s._v("dep.ts")]),s._v(" ，此文件中引用了所有必需的远程依赖关系，并且重新导出了所需的方法和类。本地模块从 "),a("code",[s._v("dep.ts")]),s._v(" 统一导入所需方法和类，避免单独使用 URL 导入外部依赖可能造成的不一致的问题。")]),s._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// dep.ts")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("export")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" assert"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" assertEquals"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" assertStringIncludes "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'https://deno.land/std@0.125.0/testing/asserts.ts'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// index.ts")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" assert "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'./dep.ts'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[s._v("Deno 处理依赖的方式虽然解决了 node_modules 带来的种种问题，但目前体验也并不是很好。首先 URL 引入依赖的方式写法比较冗余繁琐，直接引用网络上文件的安全性也值得商榷；而且需要开发者手动维护 "),a("code",[s._v("dep.ts")]),s._v(" 文件，依赖来源不清晰，依赖变更还需要更改引入依赖的本地文件；此外，依赖包的生态也远远不及 Node。")]),s._v(" "),a("p",[s._v("但 Deno 确实提供了另外一种思路，Node 的包管理器似乎只是安装依赖、生成 node_modules 的“纯工具人”，真正查找 resolve 依赖的逻辑还是在 Node 做的，所以包管理器层面也没有太多优化的空间。Yarn 的 Pnp 模式曾试图改变包管理器的地位，但也不敌强大的 Node 生态。因此 Deno 重启炉灶，将 intall 和 resolve 依赖过程合并，多余的 node_modules 与包管理器也就没什么存在的必要了。只是 Deno 当前的方式还不够成熟，期待后续的演进。")]),s._v(" "),a("h2",{attrs:{id:"结语"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[s._v("#")]),s._v(" 结语")]),s._v(" "),a("p",[s._v("虽然目前还没有完美的依赖管理方案，但纵观包管理器的历史发展，是库与开发者互相学习和持续优化的过程，并且都在不断推动着前端工程化领域的发展，我们期待未来会出现更好的解决方案。")]),s._v(" "),a("h2",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[s._v("#")]),s._v(" 参考")]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/137535779",target:"_blank",rel:"noopener noreferrer"}},[s._v("node_modules 困境"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"https://npm.github.io/how-npm-works-docs/index.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("npm:How Npm Works"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"https://yarnpkg.com/features/pnp",target:"_blank",rel:"noopener noreferrer"}},[s._v("Yarn: Plug’n’Play"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"https://pnpm.io/zh/symlinked-node-modules-structure",target:"_blank",rel:"noopener noreferrer"}},[s._v("pnpm: 基于符号链接的 node_modules 结构"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/455809528",target:"_blank",rel:"noopener noreferrer"}},[s._v("tnpm: 真·深入浅出 tnpm rapid 模式 - 如何比 pnpm 快 10 秒"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"https://deno.land/manual@v1.18.2/linking_to_external_code",target:"_blank",rel:"noopener noreferrer"}},[s._v("deno: Linking to third party code"),a("OutboundLink")],1)])]),s._v(" "),a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/t6RZAKb6mXTfXl7XbpZ_vw",target:"_blank",rel:"noopener noreferrer"}},[s._v("关于依赖管理的真相 — 前端包管理器探究"),a("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=t.exports}}]);