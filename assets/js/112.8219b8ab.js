(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{2304:function(t,s,a){"use strict";a.r(s);var n=a(4),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("正如我们今天所知，CSS 语言是 web 的一个重要组成部分。它使我们有能力绘制元素在屏幕、网页或其他媒体中的展示方式。")]),t._v(" "),n("p",[t._v("它简单、强大，而且是声明式的。我们可以很容易地实现复杂的事情，如暗黑/光明模式。然而，对它有很多误解和错误的使用。这些会把 CSS 标记变成复杂的不可读且不可扩展的代码。")]),t._v(" "),n("p",[t._v("我们如何才能防止这种情况的发生？通过遵循最佳实践，避免最常见的错误。在这篇文章中，我们将总结出 5 个最常见的错误以及如何避免它们。")]),t._v(" "),n("h2",{attrs:{id:"_1-不预先设计"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-不预先设计"}},[t._v("#")]),t._v(" 1. 不预先设计")]),t._v(" "),n("p",[t._v("不经过思考，立马动手，这样可能会更快的完成任务，这也给了我们一种速度和成就感。但，从长远来看，这会有相反的效果。")]),t._v(" "),n("p",[t._v("在写代码之前，必须要先想清楚。我们将采取什么方式来设计组件？我们想以原子的方式建立我们的组件吗？我们是否愿意创建一个可组合的实用系统？我们想要一个已经内置的 UI 库吗？我们希望我们的 CSS 是全局作用域的还是按组件作用域的？")]),t._v(" "),n("p",[t._v("有一个明确的目标将帮助我们选择最好的工具。这将使我们免于冗余和违反 DRY。 有许多有效的方法来设计一个应用程序。最常见的无效的是即兴创作。")]),t._v(" "),n("p",[t._v("我们的代码必须是可预测的，易于扩展和维护。")]),t._v(" "),n("p",[t._v("看个例子：")]),t._v(" "),n("div",{staticClass:"language-css extra-class"},[n("pre",{pre:!0,attrs:{class:"language-css"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* ❌ 到处添加离散值 */")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token selector"}},[t._v(".card")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" #edb361"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[t._v("background-color")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" #274530"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[t._v("padding")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 1rem"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* ✅ 定义基于主题的属性 */")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token selector"}},[t._v(":root")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[t._v("--primary-bg-color")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" #274530"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[t._v("--accent-text-color")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" #edb361"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[t._v("--spacing-unit")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 0.5"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token selector"}},[t._v(".card")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("var")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("--accent-text-color"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[t._v("background-color")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("var")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("--primary-bg-color"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[t._v("padding")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("calc")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("var")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("--spacing-unit"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" * 2rem"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("在上面的例子中，我们可以看到当使用 CSS 变量进行主题设计时，一切都变得可读和清晰。第一个 .card 定义看起来完全是随机的，这个组件不容易被扩展。")]),t._v(" "),n("h2",{attrs:{id:"_2-css-code-smells"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-css-code-smells"}},[t._v("#")]),t._v(" 2. CSS Code Smells")]),t._v(" "),n("p",[t._v("Code Smell 中文译名一般为“代码异味”，或“代码味道”，它是提示代码中某个地方存在错误的一个暗示，开发人员可以通过这种 smell（异味）在代码中追捕到问题。")]),t._v(" "),n("blockquote",[n("p",[t._v("Code smells 不是 bug。它们也不会妨碍系统的正常工作。它们只是一些不好的做法，会使我们的代码更难阅读和维护。")])]),t._v(" "),n("p",[t._v("在这里，列举一些最常见的以及如何克服它们：")]),t._v(" "),n("h3",{attrs:{id:"符号"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#符号"}},[t._v("#")]),t._v(" :: 符号")]),t._v(" "),n("p",[t._v("在伪元素和伪类中使用 "),n("code",[t._v("::")]),t._v(" 符号是很常见的。这是旧的 CSS 规范的一部分，浏览器继续支持它作为一种回退。然而，我们应该在伪元素中使用 "),n("code",[t._v("::")]),t._v(" ，比如 "),n("code",[t._v("::before")]),t._v(" , "),n("code",[t._v("::after")]),t._v(", "),n("code",[t._v("::frist-line...")]),t._v(" ，在伪类中使用 "),n("code",[t._v(":")]),t._v(" ，比如 "),n("code",[t._v(":link")]),t._v(", "),n("code",[t._v(":visited")]),t._v(", "),n("code",[t._v(":first-child")]),t._v("…")]),t._v(" "),n("h3",{attrs:{id:"使用字符串连接类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用字符串连接类"}},[t._v("#")]),t._v(" 使用字符串连接类")]),t._v(" "),n("p",[t._v("使用 Sass 预处理器来帮助处理我们的 CSS 代码库是非常流行的。有时在尝试 DRY 时，我们通过连接"),n("code",[t._v("&")]),t._v("操作符来创建类。")]),t._v(" "),n("div",{staticClass:"language-css extra-class"},[n("pre",{pre:!0,attrs:{class:"language-css"}},[n("code",[n("span",{pre:!0,attrs:{class:"token selector"}},[t._v(".card")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[t._v("border")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 0.5 solid rem #fff"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* ❌ failed attempt to be dry */")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token selector"}},[t._v("&-selected")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token property"}},[t._v("border-color")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" #000"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("在开发人员试图在代码库中搜索"),n("code",[t._v(".card-selected")]),t._v("类之前，似乎没有什么问题。开发者将很难找到这个类。")]),t._v(" "),n("h3",{attrs:{id:"不正确地使用缩写"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#不正确地使用缩写"}},[t._v("#")]),t._v(" 不正确地使用缩写")]),t._v(" "),n("p",[t._v("CSS 的简写非常好，可以让我们避免代码过于冗长。但是，有时我们并没有刻意地使用它们。大多数情况下，background 简写是偶然使用的。")]),t._v(" "),n("div",{staticClass:"language-css extra-class"},[n("pre",{pre:!0,attrs:{class:"language-css"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* ❌ 由于我们只是在设置一个属性，所以不需要使用简写。*/")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token selector"}},[t._v(".foo")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[t._v("background")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" #274530"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* ✅ 使用正确的CSS属性 */")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token selector"}},[t._v(".foo")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[t._v("background-color")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" #274530"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("h3",{attrs:{id:"important-的错误使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#important-的错误使用"}},[t._v("#")]),t._v(" !important 的错误使用")]),t._v(" "),n("p",[n("code",[t._v("!important")]),t._v(" 规则用于覆盖特定性规则。它的使用主要集中在覆盖一个不能以任何其他方式覆盖的样式。\n它通常用于更具体的选择器可以完成任务的场景。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('<div class="inner">\n  <p>This text is in the inner div.</p>\n</div>\n\n\n<style>\n  .inner {\n    color: blue;\n  }\n\n  /* ❌ 重写 color */\n  .inner {\n    color: orange !important;\n  }\n</style>\n\n\n<style>\n  .inner {\n    color: blue;\n  }\n\n  /* ✅ 使用一个更具体的选择器规则，该规则将优先于更一般的规则。 */\n  .inner p {\n    color: orange;\n  }\n</style>\n\n')])])]),n("p",[t._v("强制使用属性值\n在 CSS 代码库中出现一个神奇的数字是很常见的。它们带来了相当多的混乱。有时，我们可能会在代码中发现长的数字，因为开发者是为了覆盖一个他不确定的属性。")]),t._v(" "),n("div",{staticClass:"language-css extra-class"},[n("pre",{pre:!0,attrs:{class:"language-css"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* ❌ Brute 强制使这个元素位于z轴的最前面 */")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token selector"}},[t._v(".modal-confirm-dialog")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[t._v("z-index")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 9999999"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* ✅ 提前计划并定义所有可能的用例 */")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token selector"}},[t._v(".modal-confirm-dialog")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[t._v("z-index")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("var")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("--z-index-modal-type"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("h2",{attrs:{id:"_3-不对-css-类名进行作用域划分"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-不对-css-类名进行作用域划分"}},[t._v("#")]),t._v(" 3.不对 CSS 类名进行作用域划分")]),t._v(" "),n("p",[t._v("由于 CSS 语言的特性，很容易出现元素在无意中被一个糟糕的类名定型的情况。这个问题非常频繁，所以有相当多的解决方案来解决这个问题。\n在我看来，最好的两个是：")]),t._v(" "),n("ul",[n("li",[t._v("使用命名约定")]),t._v(" "),n("li",[t._v("CSS Modules")])]),t._v(" "),n("h3",{attrs:{id:"命名约定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#命名约定"}},[t._v("#")]),t._v(" 命名约定")]),t._v(" "),n("p",[t._v("最流行的命名方式是 BEM 101。它代表了 "),n("code",[t._v("Block")]),t._v(" 、 "),n("code",[t._v("Element")]),t._v(" 、 "),n("code",[t._v("Modifier")]),t._v(" 方法。")]),t._v(" "),n("div",{staticClass:"language-css extra-class"},[n("pre",{pre:!0,attrs:{class:"language-css"}},[n("code",[t._v("[block]__[element]--[modifier]\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Example */")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token selector"}},[t._v(".menu__link--blue")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  ..."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("其目的是通过让开发者了解 HTML 和 CSS 之间的关系来创建独特的名称。")]),t._v(" "),n("h3",{attrs:{id:"css-modules"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#css-modules"}},[t._v("#")]),t._v(" CSS Modules")]),t._v(" "),n("p",[t._v("我对 BEM 方法最大的担心是，它很耗时，而且要依靠开发人员来实现。CSS 模块发生在预处理器一侧，这使得它没有错误。它为我们的 CSS 模块类名生成了随机的前缀/名称。")]),t._v(" "),n("h2",{attrs:{id:"_4-使用-px-单位"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-使用-px-单位"}},[t._v("#")]),t._v(" 4. 使用 px 单位")]),t._v(" "),n("p",[t._v("像素的使用相当频繁，因为它起初看起来很容易和直观的使用。事实恰恰相反。很久以来，像素已经不再基于硬件了。它们只是基于一个光学参考单元。")]),t._v(" "),n("p",[n("code",[t._v("px")]),t._v(" 是一个绝对单位。这意味着什么呢？那就是我们不能适当地缩放以满足更多的人。")]),t._v(" "),n("p",[t._v("我们应该用什么来代替？相对单位是要走的路。我们可以依靠这些来更好地表达我们的动态布局。例如，我们可以使用 "),n("code",[t._v("ch")]),t._v(" 来表达一个基于字符数的 "),n("code",[t._v("div")]),t._v(" 宽度。")]),t._v(" "),n("div",{staticClass:"language-css extra-class"},[n("pre",{pre:!0,attrs:{class:"language-css"}},[n("code",[n("span",{pre:!0,attrs:{class:"token selector"}},[t._v(".article-column")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* ✅  我们的元素将最多容纳20个继承的字体大小的字符。 */")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[t._v("max-width")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 20ch"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("通常情况下， "),n("code",[t._v("px")]),t._v(" 最常用的替换单位是 "),n("code",[t._v("rem")]),t._v(" 和 "),n("code",[t._v("em")]),t._v(" 。它们以一种从框到文本的相对方式来表示字体的相对大小。")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("rem")]),t._v(" 表示相对于根 "),n("code",[t._v("font-size")]),t._v(" 的大小。")]),t._v(" "),n("li",[n("code",[t._v("em")]),t._v(" 表示相对于元素大小的大小。")])]),t._v(" "),n("p",[t._v("通过使用 "),n("code",[t._v("rem")]),t._v(" ，我们将能够根据用户偏好的字体大小来表达布局。\n"),n("img",{attrs:{src:a(660),alt:""}}),t._v("\n在上面的截图中，我们可以看到基于 "),n("code",[t._v("rem")]),t._v(" 单元的布局如何能够扩展并适应不同的默认字体大小。")]),t._v(" "),n("h2",{attrs:{id:"_5-忽略浏览器支持"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-忽略浏览器支持"}},[t._v("#")]),t._v(" 5. 忽略浏览器支持")]),t._v(" "),n("p",[t._v("当开始开发一个网站时，定义我们的目标客户是至关重要的。跳过这一步，直接进行编码是很常见的。\n为什么它至关重要?它帮助我们了解我们的应用程序将在哪种设备上使用。之后，我们可以定义我们将支持哪些浏览器和哪些版本。\n只要我们能提供适当的后备方案，我们仍然可以致力于接受像 "),n("code",[t._v("subgrid")]),t._v(" 这样的后期功能。定义一个渐进的功能体验总是一个好主意。当一个特性得到更多的支持时，我们可以逐步抛弃它的后备方案。\n像 "),n("a",{attrs:{href:"http://caniuse.com",target:"_blank",rel:"noopener noreferrer"}},[t._v("caniuse.com"),n("OutboundLink")],1),t._v(" 或 browserslist.dev 这样的工具在这方面很有帮助。像 "),n("code",[t._v("postcss")]),t._v(" 这样的工具自带的 "),n("code",[t._v("autoprefixer")]),t._v(" 功能将帮助我们的 CSS 得到更广泛的支持。")]),t._v(" "),n("h2",{attrs:{id:"_6-总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-总结"}},[t._v("#")]),t._v(" 6. 总结")]),t._v(" "),n("p",[t._v("我们已经看到了如何改进我们的 CSS 代码。遵循一些简单的指导原则，我们可以实现一个声明式、可重用和可读的代码库。我们应该在 CSS 中投入和在 Javascript 中一样多的精力。")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://levelup.gitconnected.com/top-5-css-mistakes-to-avoid-963f76892954",target:"_blank",rel:"noopener noreferrer"}},[t._v("5 个需要避免的 CSS 错误"),n("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=e.exports}}]);