(window.webpackJsonp=window.webpackJsonp||[]).push([[235],{2433:function(t,a,v){"use strict";v.r(a);var e=v(4),_=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"基本用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本用法"}},[t._v("#")]),t._v(" 基本用法")]),t._v(" "),e("p",[e("img",{attrs:{src:v(975),alt:""}}),t._v("\n上面的四条命令在工作目录、暂存目录(也叫做索引)和仓库之间复制文件。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("git add *files*")]),t._v(" 把当前文件放入暂存区域。")]),t._v(" "),e("li",[e("code",[t._v("git commit")]),t._v(" 给暂存区域生成快照并提交。")]),t._v(" "),e("li",[e("code",[t._v("git reset -- *files*")]),t._v(" 用来撤销最后一次 "),e("code",[t._v("git add *files*")]),t._v("，你也可以用 "),e("code",[t._v("git reset")]),t._v(" 撤销所有暂存区域文件。")]),t._v(" "),e("li",[e("code",[t._v("git checkout -- *files*")]),t._v(" 把文件从暂存区域复制到工作目录，用来丢弃本地修改。\n你可以用 "),e("code",[t._v("git reset -p")]),t._v(" , "),e("code",[t._v("git checkout -p")]),t._v(" , 或 "),e("code",[t._v("git add -p")]),t._v(" 进入交互模式。")])]),t._v(" "),e("p",[t._v("也可以跳过暂存区域直接从仓库取出文件或者直接提交代码。")]),t._v(" "),e("figure",[e("img",{attrs:{src:v(986),alt:""}}),e("figcaption",[t._v("章节配图")])]),t._v(" "),e("ul",[e("li",[e("code",[t._v("git commit -a")]),t._v(" 相当于运行 "),e("code",[t._v("git add")]),t._v(" 把所有当前目录下的文件加入暂存区域再运行。"),e("code",[t._v("git commit")]),t._v(" 。")]),t._v(" "),e("li",[e("code",[t._v("git commit *files*")]),t._v(" 进行一次包含最后一次提交加上工作目录中文件快照的提交。并且文件被添加到暂存区域。")]),t._v(" "),e("li",[e("code",[t._v("git checkout HEAD -- *files*")]),t._v(" 回滚到复制最后一次提交。")])]),t._v(" "),e("h2",{attrs:{id:"约定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#约定"}},[t._v("#")]),t._v(" 约定")]),t._v(" "),e("p",[t._v("后文中以下面的形式使用图片。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(989),alt:""}}),t._v("\n绿色的 5 位字符表示提交的 ID，分别指向父节点。分支用橘色显示，分别指向特定的提交。当前分支由附在其上的 HEAD 标识。这张图片里显示最后 5 次提交，ed489 是最新提交。main 分支指向此次提交，另一个 stable 分支指向祖父提交节点。")]),t._v(" "),e("h2",{attrs:{id:"命令详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#命令详解"}},[t._v("#")]),t._v(" 命令详解")]),t._v(" "),e("h3",{attrs:{id:"diff"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#diff"}},[t._v("#")]),t._v(" Diff")]),t._v(" "),e("p",[t._v("有许多种方法查看两次提交之间的变动。下面是一些示例。")]),t._v(" "),e("figure",[e("img",{attrs:{src:v(990),alt:""}}),e("figcaption",[t._v("章节配图")])]),t._v(" "),e("h3",{attrs:{id:"commit"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#commit"}},[t._v("#")]),t._v(" Commit")]),t._v(" "),e("p",[t._v("提交时，git 用暂存区域的文件创建一个新的提交，并把此时的节点设为父节点。然后把当前分支指向新的提交节点。下图中，当前分支是 main。在运行命令之前，main 指向 ed489，提交后，main 指向新的节点 f0cec 并以 ed489 作为父节点。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(991),alt:""}}),t._v("\n即便当前分支是某次提交的祖父节点，git 会同样操作。下图中，在 main 分支的祖父节点 stable 分支进行一次提交，生成了 1800b。这样，stable 分支就不再是 main 分支的祖父节点。此时，合并 (或者 衍合) 是必须的。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(992),alt:""}}),t._v("\n如果想更改一次提交，使用 "),e("code",[t._v("git commit --amend")]),t._v(" 。git 会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(993),alt:""}}),t._v("\n另一个例子是分离 HEAD 提交,后文讲。另外，Git 系列面试题整理好了，微信搜索 Java 技术栈，在后台发送：面试，面试题非常全。")]),t._v(" "),e("h3",{attrs:{id:"checkout"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#checkout"}},[t._v("#")]),t._v(" Checkout")]),t._v(" "),e("p",[t._v("checkout 命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。")]),t._v(" "),e("p",[t._v("当给定某个文件名（或者打开 "),e("code",[t._v("-p")]),t._v(" 选项，或者文件名和 "),e("code",[t._v("-p")]),t._v(" 选项同时打开）时，git 会从指定的提交中拷贝文件到暂存区域和工作目录。比如，"),e("code",[t._v("git checkout HEAD~ foo.c")]),t._v(" 会将提交节点 "),e("code",[t._v("HEAD~")]),t._v(" (即当前提交节点的父节点)中的 "),e("code",[t._v("foo.c")]),t._v(" 复制到工作目录并且加到暂存区域中。（如果命令中没有指定提交节点，则会从暂存区域中拷贝内容。）注意当前分支不会发生变化。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(994),alt:""}}),t._v("\n当不指定文件名，而是给出一个（本地）分支时，那么 HEAD 标识会移动到那个分支（也就是说，我们“切换”到那个分支了），然后暂存区域和工作目录中的内容会和 HEAD 对应的提交节点一致。新提交节点（下图中的 a47c3）中的所有文件都会被复制（到暂存区域和工作目录中）；只存在于老的提交节点（ed489）中的文件会被删除；不属于上述两者的文件会被忽略，不受影响。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(995),alt:""}}),t._v("\n如果既没有指定文件名，也没有指定分支名，而是一个标签、远程分支、"),e("code",[t._v("SHA-1")]),t._v(" 值或者是像 "),e("code",[t._v("main~3")]),t._v(" 类似的东西，就得到一个匿名分支，称作 "),e("code",[t._v("detached HEAD")]),t._v(" （被分离的 HEAD 标识）。")]),t._v(" "),e("p",[t._v("这样可以很方便地在历史版本之间互相切换。比如说你想要编译 1.6.6.1 版本的 git，你可以运行 git checkout v1.6.6.1（这是一个标签，而非分支名），编译，安装，然后切换回另一个分支，比如说 "),e("code",[t._v("git checkout main")]),t._v(" 。然而，当提交操作涉及到“分离的 HEAD”时，其行为会略有不同，详情见在下面。")]),t._v(" "),e("figure",[e("img",{attrs:{src:v(976),alt:""}}),e("figcaption",[t._v("章节配图")])]),t._v(" "),e("h3",{attrs:{id:"head-标识处于分离状态时的提交操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#head-标识处于分离状态时的提交操作"}},[t._v("#")]),t._v(" HEAD 标识处于分离状态时的提交操作")]),t._v(" "),e("p",[t._v("当 HEAD 处于分离状态（不依附于任一分支）时，提交操作可以正常进行，但是不会更新任何已命名的分支。(你可以认为这是在更新一个匿名分支。)")]),t._v(" "),e("p",[e("img",{attrs:{src:v(977),alt:""}}),t._v("\n一旦此后你切换到别的分支，比如说 main，那么这个提交节点（可能）再也不会被引用到，然后就会被丢弃掉了。注意这个命令之后就不会有东西引用 2eecb。分享给你：Spring Boot 学习笔记。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(978),alt:""}}),t._v("\n但是，如果你想保存这个状态，可以用命令 "),e("code",[t._v("git checkout -b *name*")]),t._v(" 来创建一个新的分支。")]),t._v(" "),e("figure",[e("img",{attrs:{src:v(979),alt:""}}),e("figcaption",[t._v("章节配图")])]),t._v(" "),e("h3",{attrs:{id:"reset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reset"}},[t._v("#")]),t._v(" Reset")]),t._v(" "),e("p",[t._v("reset 命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。")]),t._v(" "),e("p",[t._v("如果不给选项，那么当前分支指向到那个提交。如果用 "),e("code",[t._v("--hard")]),t._v(" 选项，那么工作目录也更新，如果用 "),e("code",[t._v("--soft")]),t._v(" 选项，那么都不变。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(980),alt:""}}),t._v("\n如果没有给出提交点的版本号，那么默认用 HEAD。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用–hard 选项，工作目录也同样。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(981),alt:""}}),t._v("\n如果给了文件名(或者 -p 选项), 那么工作效果和带文件名的 checkout 差不多，除了索引被更新。Java 核心技术教程和示例源码："),e("a",{attrs:{href:"https://github.com/javastacks/javastack",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/javastacks/javastack"),e("OutboundLink")],1)]),t._v(" "),e("figure",[e("img",{attrs:{src:v(982),alt:""}}),e("figcaption",[t._v("章节配图")])]),t._v(" "),e("h3",{attrs:{id:"merge"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#merge"}},[t._v("#")]),t._v(" Merge")]),t._v(" "),e("p",[t._v("merge 命令把不同分支合并起来。合并前，索引必须和当前提交相同。如果另一个分支是当前提交的祖父节点，那么合并命令将什么也不做。另一种情况是如果当前提交是另一个分支的祖父节点，就导致 "),e("code",[t._v("fast-forward")]),t._v(" 合并。指向只是简单的移动，并生成一个新的提交。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(983),alt:""}}),t._v("\n否则就是一次真正的合并。默认把当前提交(ed489 如下所示)和另一个提交(33104)以及他们的共同祖父节点(b325c)进行一次三方合并。结果是先保存当前目录和索引，然后和父节点 33104 一起做一次新提交。")]),t._v(" "),e("figure",[e("img",{attrs:{src:v(984),alt:""}}),e("figcaption",[t._v("章节配图")])]),t._v(" "),e("h3",{attrs:{id:"cherry-pick"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cherry-pick"}},[t._v("#")]),t._v(" Cherry Pick")]),t._v(" "),e("p",[e("code",[t._v("cherry-pick")]),t._v(' 命令"复制"一个提交节点并在当前分支做一次完全一样的新提交。')]),t._v(" "),e("figure",[e("img",{attrs:{src:v(985),alt:""}}),e("figcaption",[t._v("章节配图")])]),t._v(" "),e("h3",{attrs:{id:"rebase"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rebase"}},[t._v("#")]),t._v(" Rebase")]),t._v(" "),e("p",[t._v("衍合是合并命令的另一种选择。合并把两个父分支合并进行一次提交，提交历史不是线性的。衍合在当前分支上重演另一个分支的历史，提交历史是线性的。本质上，这是线性化的自动的 "),e("code",[t._v("cherry-pick")])]),t._v(" "),e("p",[e("img",{attrs:{src:v(987),alt:""}}),t._v("\n上面的命令都在 topic 分支中进行，而不是 main 分支，在 main 分支上重演，并且把分支指向新的节点。注意旧提交没有被引用，将被回收。")]),t._v(" "),e("p",[t._v("要限制回滚范围，使用 "),e("code",[t._v("--onto")]),t._v(" 选项。下面的命令在 main 分支上重演当前分支从 169a6 以来的最近几个提交，即 2c33a。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(988),alt:""}}),t._v("\n同样有 "),e("code",[t._v("git rebase --interactive")]),t._v(" 让你更方便的完成一些复杂操作，比如丢弃、重排、修改、合并提交。")]),t._v(" "),e("h2",{attrs:{id:"技术说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#技术说明"}},[t._v("#")]),t._v(" 技术说明")]),t._v(" "),e("p",[t._v("文件内容并没有真正存储在索引(.git/index)或者提交对象中，而是以 blob 的形式分别存储在数据库中(.git/objects)，并用 "),e("code",[t._v("SHA-1")]),t._v(" 值来校验。索引文件用识别码列出相关的 blob 文件以及别的数据。对于提交来说，以树(tree)的形式存储，同样用对于的哈希值识别。树对应着工作目录中的文件夹，树中包含的 树或者 blob 对象对应着相应的子目录和文件。每次提交都存储下它的上一级树的识别码。")]),t._v(" "),e("p",[t._v("如果用 "),e("code",[t._v("detached HEAD")]),t._v(" 提交，那么最后一次提交会被 "),e("code",[t._v("the reflog for HEAD")]),t._v(" 引用。但是过一段时间就失效，最终被回收，与 "),e("code",[t._v("git commit --amend")]),t._v(" 或者 "),e("code",[t._v("git rebase")]),t._v(" 很像。")]),t._v(" "),e("p",[e("a",{attrs:{href:"http://marklodato.github.io/visual-git-guide/index-zh-cn.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("图解 Git 各种用法"),e("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=_.exports}}]);